#pragma kernel Fill
#pragma kernel SphereForce
#pragma kernel CapsuleForce
#pragma kernel BoxForce
#pragma kernel ProjectInit
#pragma kernel ProjectIteration
#pragma kernel ProjectBake
#pragma kernel Advection
#pragma kernel TempToMain

#pragma warning(disable : 4008) // WARN_FLOAT_DIVISION_BY_ZERO
const static float NaN = 0.0f / 0.0f;

// ##########################
// #         Common         #
// ##########################

RWTexture3D<float4> MainTexture;
RWTexture3D<float4> TempTexture;
uint3 GridSize;     // blocks * blockSize

bool inSimulationArea(uint3 id) {
    return
        id.x > 0 && id.y > 0 && id.z > 0
        && id.x < GridSize.x - 1
        && id.y < GridSize.y - 1
        && id.z < GridSize.z - 1;
}

// ##########################
// #          Fill          #
// ##########################

float4 FillValue;

[numthreads(16, 16, 2)]
void Fill(uint3 id : SV_DispatchThreadID)
{
    MainTexture[id] = FillValue;
}


// ##########################
// #       Projection       #
// ##########################


[numthreads(16, 16, 2)]
void ProjectInit(uint3 id : SV_DispatchThreadID)
{
    uint3 target = id;
    float3 flip = float3(0, 0, 0);
    bool in_sim = true;
    if (id.x == 0) { target.x += 1; flip.x = -1; in_sim = false; }
    if (id.y == 0) { target.y += 1; flip.y = -1; in_sim = false; }
    if (id.z == 0) { target.z += 1; flip.z = -1; in_sim = false; }
    if (id.x == GridSize.x - 1) { target.x -= 1; flip.x = -1; in_sim = false; }
    if (id.y == GridSize.y - 1) { target.y -= 1; flip.y = -1; in_sim = false; }
    if (id.z == GridSize.z - 1) { target.z -= 1; flip.z = -1; in_sim = false; }
    float4 value = MainTexture[target];
    value.xyz = value.xyz * GridSize;
    float4 result = in_sim ?
        float4(value.xyz, isnan(value.w) ? value.w : 0) :
        float4(value.xyz * flip, NaN);
    MainTexture[id] = result;
}

[numthreads(16, 16, 2)]
void ProjectIteration(uint3 id : SV_DispatchThreadID)
{
    float4 value = MainTexture[id];
    if (isnan(value.w))
        return;

    float4 vx_p = MainTexture[id + uint3(1, 0, 0)];
    float4 vy_p = MainTexture[id + uint3(0, 1, 0)];
    float4 vz_p = MainTexture[id + uint3(0, 0, 1)];

    float4 vx_n = MainTexture[id - uint3(1, 0, 0)];
    float4 vy_n = MainTexture[id - uint3(0, 1, 0)];
    float4 vz_n = MainTexture[id - uint3(0, 0, 1)];

    float div = 0.5 * (
        + vx_p.x - vx_n.x
        + vy_p.y - vy_n.y
        + vz_p.z - vz_n.z
    );

    float p =
        + (isnan(vx_p.w) ? 0 : vx_p.w)
        + (isnan(vx_n.w) ? 0 : vx_n.w)
        + (isnan(vy_p.w) ? 0 : vy_p.w)
        + (isnan(vy_n.w) ? 0 : vy_n.w)
        + (isnan(vz_p.w) ? 0 : vz_p.w)
        + (isnan(vz_n.w) ? 0 : vz_n.w);

    MainTexture[id] = float4(value.xyz, (p - div) * (1.0 / 6.0));
}

[numthreads(16, 16, 2)]
void ProjectBake(uint3 id : SV_DispatchThreadID)
{
    float4 value = MainTexture[id];
    float4 vx_p = MainTexture[id + uint3(1, 0, 0)];
    float4 vy_p = MainTexture[id + uint3(0, 1, 0)];
    float4 vz_p = MainTexture[id + uint3(0, 0, 1)];

    float4 vx_n = MainTexture[id - uint3(1, 0, 0)];
    float4 vy_n = MainTexture[id - uint3(0, 1, 0)];
    float4 vz_n = MainTexture[id - uint3(0, 0, 1)];

    float3 result = value.xyz;
    if (!isnan(value.w))
    {
        float3 grad_p = 0.5 * float3(
            + (isnan(vx_p.w) ? 0 : vx_p.w)
            - (isnan(vx_n.w) ? 0 : vx_n.w),
            + (isnan(vy_p.w) ? 0 : vy_p.w)
            - (isnan(vy_n.w) ? 0 : vy_n.w),
            + (isnan(vz_p.w) ? 0 : vz_p.w)
            - (isnan(vz_n.w) ? 0 : vz_n.w)
        );
        result -= grad_p;
    }
    MainTexture[id] = float4(result / GridSize, 0);
}

// ##########################
// #       Projection       #
// ##########################

float AdvectionDeltaTime;

[numthreads(16, 16, 2)]
void Advection(uint3 id : SV_DispatchThreadID)
{
    if (!inSimulationArea(id))
        return;
    float4 value = MainTexture[id];
    float3 delta = value.xyz * GridSize * AdvectionDeltaTime;
    float3 p = id - delta;
    if (p.x < 0) p.x = 0;
    if (p.y < 0) p.y = 0;
    if (p.z < 0) p.z = 0;
    if (p.x >= int(GridSize.x) - 1) p.x = GridSize.x - (1 + 1e-5f);
    if (p.y >= int(GridSize.y) - 1) p.y = GridSize.y - (1 + 1e-5f);
    if (p.z >= int(GridSize.z) - 1) p.z = GridSize.z - (1 + 1e-5f);

    uint3 int_p = floor(p);
    float3 dp = p - int_p;
    float3 dn = 1 - dp;
    TempTexture[id] = (
        + MainTexture[int_p + uint3(0, 0, 0)] * dn.x * dn.y * dn.z
        + MainTexture[int_p + uint3(0, 0, 1)] * dn.x * dn.y * dp.z
        + MainTexture[int_p + uint3(0, 1, 0)] * dn.x * dp.y * dn.z
        + MainTexture[int_p + uint3(0, 1, 1)] * dn.x * dp.y * dp.z
        + MainTexture[int_p + uint3(1, 0, 0)] * dp.x * dn.y * dn.z
        + MainTexture[int_p + uint3(1, 0, 1)] * dp.x * dn.y * dp.z
        + MainTexture[int_p + uint3(1, 1, 0)] * dp.x * dp.y * dn.z
        + MainTexture[int_p + uint3(1, 1, 1)] * dp.x * dp.y * dp.z
    );
}

[numthreads(16, 16, 2)]
void TempToMain(uint3 id : SV_DispatchThreadID)
{
    MainTexture[id] = TempTexture[id];
}


// ##########################
// #        Colliders       #
// ##########################

float3 SphereCenter;
float SphereRadius;

bool collideSphere(uint3 id)
{
    float3 d = id - SphereCenter;
    float r2 = d.x * d.x + d.y * d.y + d.z * d.z;
    return r2 <= SphereRadius * SphereRadius;
}

float3 CapsulePoint;
float3 CapsuleDirection;
float CapsuleDividedHeight2;
float CapsuleRadius;

bool collideCapsule(uint3 id)
{
    float3 d = id - CapsulePoint;
    d -= CapsuleDirection * clamp(dot(d, CapsuleDirection) * CapsuleDividedHeight2, 0, 1);
    float r2 = d.x * d.x + d.y * d.y + d.z * d.z;
    return r2 <= CapsuleRadius * CapsuleRadius;
}

float3 BoxCenter;
float3 BoxHalfSize;
float4x4 BoxRotation;

bool collideBox(uint3 id)
{
    float3 d = id - BoxCenter;
    d = abs(mul((float3x3)BoxRotation, d));
    return d.x < BoxHalfSize.x && d.y < BoxHalfSize.y && d.z < BoxHalfSize.z;
}


// ##########################
// #          Force         #
// ##########################

float3 ForceValue;

void applyForce(uint3 id)
{
    float4 cell = MainTexture[id];
    MainTexture[id] = float4(cell.xyz + ForceValue, cell.w);
}

[numthreads(16, 16, 2)]
void SphereForce(uint3 id : SV_DispatchThreadID)
{
    if (!inSimulationArea(id)) return;
    if (!collideSphere(id)) return;
    applyForce(id);
}

[numthreads(16, 16, 2)]
void CapsuleForce(uint3 id : SV_DispatchThreadID)
{
    if (!inSimulationArea(id)) return;
    if (!collideCapsule(id)) return;
    applyForce(id);
}

[numthreads(16, 16, 2)]
void BoxForce(uint3 id : SV_DispatchThreadID)
{
    if (!inSimulationArea(id)) return;
    if (!collideBox(id)) return;
    applyForce(id);
}
